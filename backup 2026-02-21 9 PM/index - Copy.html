<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tank Wars</title>
<script src="https://cdn.tailwindcss.com/3.4.17"></script>
<style> @import
url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
* { box-sizing: border-box; } html, body {
font-family: 'Orbitron', sans-serif; margin: 0;
padding: 0;
height: 100%;
width: 100%;
}

body {
overflow: hidden;
}

.explosion {
animation: explode 0.5s ease-out forwards;
}

@keyframes explode {
0% { transform: scale(0); opacity: 1; } 50% { transform: scale(1.5); opacity: 0.8; } 100% { transform: scale(2); opacity: 0; }
}

.trajectory-point {
animation: twinkle 0.8s infinite;
}

@keyframes twinkle {
0%, 100% { opacity: 0.3; }
50% { opacity: 1; }
}
 
</style>
</head>
<body class="h-full w-full bg-gradient-to-b from-indigo-950 via-slate-900 to-slate-950">
<div id="app" class="h-full w-full"></div>

<script>


const defaultConfig = { game_title: 'Tank Wars'
};

let gameState = { phase: 'setup', players: [], currentPlayerIndex: 0,
round: 1, terrain: null, terrainCtx: null, projectile: null, canFire: true,
shopOpen: false, explosions: [], planes: [],
bombs: [], beamLine: null, flameColumn: null, trajectoryPoints: [], hasTargeting: false,
empDisabledPlayers: new Set(), tmp360AimTurns: 0
};

const TANK_WIDTH = 24; const TANK_HEIGHT = 14; const CANVAS_WIDTH = 1200; const CANVAS_HEIGHT = 600;

const ANGLE_INCREMENT = 4;
const POWER_INCREMENT = 7;

const DEV_MODE = true;

const COLORS = {
red: { primary: '#ef4444', dark: '#b91c1c', light: '#fca5a5', glow: '#dc2626' }, 
blue: { primary: '#3b82f6', dark: '#1d4ed8', light: '#93c5fd', glow: '#1e40af' }, 
green: { primary: '#22c55e', dark: '#15803d', light: '#86efac', glow: '#16a34a' }, 
yellow: { primary: '#eab308', dark: '#a16207', light: '#fde047', glow: '#ca8a04' }
};

const WEAPONS = {
 
standard: { name: 'Standard', damage: 25, radius: 20, price: 0 },
medium: { name: 'Medium Shell', damage: 35, radius: 28, price: 150, oneTime: true }, large: { name: 'Large Shell', damage: 50, radius: 40, price: 250, oneTime: true },
cannonball: { name: 'Cannon Ball', damage: 30, radius: 25, bounces: 3, price: 200, oneTime: true },
sniper: { name: 'Sniper Shot', damage: 100, radius: 8, price: 300, oneTime: true }, atomic: { name: 'Atomic Bomb', damage: 80, radius: 120, price: 500, oneTime: true },
flamethrower: { name: 'Flamethrower', damage: 25, burnDamage: 15, burnTurns: 4, radius: 0, price: 350, oneTime: true },
guided: { name: 'Guided Shot', damage: 45, radius: 30, guided: true, price: 400, oneTime: true },
plasma: { name: 'Plasma Blast', damage: 60, radius: 35, beam: true, price: 450, oneTime: true },
airstrike: { name: 'Airstrike', damage: 999, price: 600, oneTime: true },
emp: { name: 'EMP Blast', damage: 15, radius: 50, emp: true, price: 550, oneTime: true }
};


// Simple Perlin noise implementation
const PerlinNoise = {
    // Permutation table for gradient selection
    permutation: [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,
        142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,
        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,
        139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,
        245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,
        196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,
        202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,
        170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,
        98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,
        144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,
        184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,
        141,128,195,78,66,215,61,156,180],
    
    p: [],
    
    init() {
        // Double the permutation table for overflow
        for (let i = 0; i < 256; i++) {
            this.p[256 + i] = this.p[i] = this.permutation[i];
        }
    },
    
    // Fade function for smoothing
    fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    },
    
    // Linear interpolation
    lerp(t, a, b) {
        return a + t * (b - a);
    },
    
    // Gradient function
    grad(hash, x, y) {
        const h = hash & 15;
        const u = h < 8 ? x : y;
        const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
        return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
    },
    
    // 2D Perlin noise function
    noise(x, y) {
        if (this.p.length === 0) this.init();
        
        // Find unit grid cell
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        
        // Get relative coordinates
        x -= Math.floor(x);
        y -= Math.floor(y);
        
        // Compute fade curves
        const u = this.fade(x);
        const v = this.fade(y);
        
        // Hash coordinates of the 4 corners
        const a = this.p[X] + Y;
        const b = this.p[X + 1] + Y;
        
        // And add blended results from 4 corners
        return this.lerp(v,
            this.lerp(u,
                this.grad(this.p[a], x, y),
                this.grad(this.p[b], x - 1, y)
            ),
            this.lerp(u,
                this.grad(this.p[a + 1], x, y - 1),
                this.grad(this.p[b + 1], x - 1, y - 1)
            )
        ) * 0.5 + 0.5; // Normalize to 0-1 range
    }
};


window.tankWars = {
    selectedColors: new Set(),

    togglePlayer(color) {
        if (this.selectedColors.has(color)) {
            this.selectedColors.delete(color);
        } else if (this.selectedColors.size < 4) {
            this.selectedColors.add(color);
        }
        
        document.querySelectorAll('[id^="btn-"]').forEach(btn => {
            const c = btn.id.replace('btn-', '');
            const check = document.getElementById(`check-${c}`);
            if (this.selectedColors.has(c)) {
                btn.style.background = `linear-gradient(135deg, ${COLORS[c].primary}60, ${COLORS[c].primary}40)`;
                btn.style.boxShadow = `0 0 20px ${COLORS[c].primary}80`;
                check.textContent = '‚óè';
            } else {
                btn.style.background = `linear-gradient(135deg, ${COLORS[c].dark}40, ${COLORS[c].dark}20)`;
                btn.style.boxShadow = 'none';
                check.textContent = '‚óã';
            }
        });
        
        document.getElementById('startBtn').disabled = this.selectedColors.size < 2;
    },

    startGame() {
        if (this.selectedColors.size < 2) return;
        
        const colors = Array.from(this.selectedColors);
        gameState.players = colors.map((color, index) => createPlayer(color, index));
        
        const terrainTypes = ['hills', 'mountains', 'canyons', 
                              'ruins', 'valley', 'plateau', 'random'
                                ];
        const selectedType = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
        
        console.log("Selected terrain type:", selectedType);
        
        generateTerrain(selectedType);
        
        positionPlayers();

        
        
        gameState.currentPlayerIndex = 0;
        gameState.phase = 'playing';
        gameState.round = 1;
        
        render();
    },

    adjustAngle(delta) {
        const player = gameState.players[gameState.currentPlayerIndex];
        if (!player || !player.alive || player.hasFired) return;
        
        if (player.tmp360AimTurns > 0) {
            player.angle = (player.angle - delta + 360) % 360;
        } else {
            player.angle = Math.max(0, Math.min(180, player.angle - delta));
        }
        render();
    },

    adjustPower(delta) {
        const player = gameState.players[gameState.currentPlayerIndex];
        if (!player || !player.alive || player.hasFired) return;
        
        player.power = Math.max(20, Math.min(100, player.power + delta));
        render();
    },

    selectWeapon(weapon) {
        const player = gameState.players[gameState.currentPlayerIndex];
        if (!player || !player.alive) return;
        
        player.selectedWeapon = weapon;
        gameState.hasTargeting = false;
        render();
    },

    moveTank(direction) {
        const player = gameState.players[gameState.currentPlayerIndex];
        if (!player || !player.alive || player.hasFired || player.isPlane || player.empDisabled || player.gas < 5) return;
        
        player.gas -= 5;
        player.x = Math.max(30, Math.min(CANVAS_WIDTH - 30, player.x + direction * 25));
        player.y = getTerrainHeight(player.x) - TANK_HEIGHT;
        render();
    },

    movePlane(direction) {
        const player = gameState.players[gameState.currentPlayerIndex];
        if (!player || !player.alive || !player.isPlane || player.hasFired) return;
        
        player.x = Math.max(30, Math.min(CANVAS_WIDTH - 30, player.x + direction * 40));
        render();
    },

    toggleShop() {
        if (!gameState.canFire) return;
        gameState.shopOpen = !gameState.shopOpen;
        render();
    },

    buyItem(item) {
    const player = gameState.players[gameState.currentPlayerIndex];
    if (!player || !player.alive || player.empDisabled) return;
    
    let price = 0;
    if (item === 'plane') price = 2000;
    else if (item === '360aim') price = 150;
    else if (item === 'targeting') price = 250;
    else if (item === 'shield') price = 150;
    else if (item.startsWith('luckybox')) {
        const tier = item.replace('luckybox', '');
        if (tier === '1') price = 50;
        else if (tier === '2') price = 125;
        else if (tier === '3') price = 250;
    } else {
        price = WEAPONS[item]?.price || (item === 'gas' ? 50 : item === 'health' ? 75 : 100);
    }
    
    if (player.money < price) return;
    player.money -= price;
    
    switch(item) {
        case 'plane':
            player.isPlane = true;
            player.planeHealth = 100;
            player.y = 100;
            break;
        case '360aim':
            player.tmp360AimTurns = 1;
            break;
        case 'gas':
            player.gas = Math.min(100, player.gas + 30);
            break;
        case 'health':
            if (player.isPlane) {
                player.planeHealth = Math.min(100, player.planeHealth + 30);
            } else {
                player.health = Math.min(100, player.health + 30);
            }
            break;
        case 'shield':
            player.shield = true;
            break;
        case 'targeting':
            gameState.hasTargeting = true;
            break;
        case 'luckybox1':
            openLuckyBox(1);
            return;
        case 'luckybox2':
            openLuckyBox(2);
            return;
        case 'luckybox3':
            openLuckyBox(3);
            return;
        default:
            // Always push the weapon, even if the player already has one
            player.weapons.push(item);
    }
    
    gameState.shopOpen = false;
    render();
},

    fire() {
    const player = gameState.players[gameState.currentPlayerIndex];
    if (!player || !player.alive || player.hasFired || !gameState.canFire) return;

    const weapon = player.selectedWeapon;
    gameState.shopOpen = false;
    
    if (player.empDisabled && (weapon === 'flamethrower' || weapon === 'plasma' || weapon === 'airstrike' || weapon === 'guided' || weapon === 'emp')) {
        return;
    }

    if (weapon === 'airstrike') {
        this.launchAirstrike(player);
        return;
    }
    if (weapon === 'flamethrower') {
        this.launchFlamethrower(player);
        return;
    }
    if (weapon === 'plasma') {
        this.launchPlasma(player);
        return;
    }
    if (weapon === 'emp') {
        this.launchEMP(player);
        return;
    }

    const angleRad = (180 - player.angle) * (Math.PI / 180);
    const speed = player.power * 0.12;
    
    gameState.projectile = {
        x: player.x + Math.cos(angleRad) * 18,
        y: player.y - 5 - Math.sin(angleRad) * 18,
        vx: Math.cos(angleRad) * speed,
        vy: -Math.sin(angleRad) * speed,
        type: weapon,
        owner: player.id,
        bounces: WEAPONS[weapon].bounces || 0,
        guided: WEAPONS[weapon].guided || false
    };
    
    gameState.canFire = false;
    player.hasFired = true;
    gameState.hasTargeting = false;
    
    if (WEAPONS[weapon].oneTime) {
        // Remove only one copy of the weapon
        const index = player.weapons.indexOf(weapon);
        if (index !== -1) {
            player.weapons.splice(index, 1);
        }
        // If no more copies, fallback to standard
        if (!player.weapons.includes('standard')) {
            player.weapons.unshift('standard');
        }
        player.selectedWeapon = 'standard';
    }
    
    render();
    this.animateProjectile();
},

        // Add to your window.tankWars object at the beginning (with your other properties)
    lastTimestamp: null,
    frameCount: 0,

    animateProjectile(timestamp) {
        if (!gameState.projectile) {
            // Reset timestamp when no projectile
            this.lastTimestamp = null;
            return;
        }
        
        // Initialize on first frame
        if (!this.lastTimestamp) {
            this.lastTimestamp = timestamp;
            requestAnimationFrame((t) => this.animateProjectile(t));
            return;
        }
        
        // Calculate delta time in seconds
        const dt = (timestamp - this.lastTimestamp) / 1000; // Convert ms to seconds
        this.lastTimestamp = timestamp;
        
        // Cap dt to prevent huge jumps (max 0.1 seconds)
        const safeDt = Math.min(dt, 0.1);
        
        // Calculate multiplier to maintain 60fps feel
        // If dt is 0.0167 (60fps), multiplier = 1
        // If dt is 0.0333 (30fps), multiplier = 2
        const multiplier = safeDt * 58; // Much simpler!
        
        const proj = gameState.projectile;
        
        // Apply ALL movement with the multiplier
        proj.vy += 0.12 * multiplier;
        proj.x += proj.vx * multiplier;
        proj.y += proj.vy * multiplier;
        
        // Guided missile logic
        if (proj.guided) {
            let nearestDist = Infinity;
            let nearestPlayer = null;

            gameState.players.forEach(p => {
                if (p.id !== proj.owner && p.alive) {
                    const dist = Math.hypot(p.x - proj.x, p.y - proj.y);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestPlayer = p;
                    }
                }
            });

            if (nearestPlayer && nearestDist < 400) {
                const targetAngle = Math.atan2(nearestPlayer.y - proj.y, nearestPlayer.x - proj.x);
                const currentAngle = Math.atan2(proj.vy, proj.vx);
                let angleDiff = targetAngle - currentAngle;

                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                const turnRate = 0.06 * multiplier;
                const newAngle = currentAngle + angleDiff * turnRate;
                const speed = Math.hypot(proj.vx, proj.vy);

                proj.vx = Math.cos(newAngle) * speed;
                proj.vy = Math.sin(newAngle) * speed;
            }
        }

        const terrainY = getTerrainHeight(proj.x);
        if (proj.y >= terrainY) {
            if (proj.bounces > 0) {
                proj.bounces--;
                proj.y = terrainY - 3;
                proj.vy = -proj.vy * 0.65;
                proj.vx *= 0.75;
            } else {
                this.handleExplosion(proj.x, proj.y, proj.type, proj.owner);
                this.lastTimestamp = null; // Reset for next projectile
                return;
            }
        }

        for (const p of gameState.players) {
            if (!p.alive || p.id === proj.owner) continue;
            const dist = Math.hypot(p.x - proj.x, (p.y + TANK_HEIGHT / 2) - proj.y);
            if (dist < TANK_WIDTH / 2 + 4) {
                this.handleExplosion(proj.x, proj.y, proj.type, proj.owner, p);
                this.lastTimestamp = null; // Reset for next projectile
                return;
            }
        }

        if (proj.x < -50 || proj.x > CANVAS_WIDTH + 50 || proj.y > CANVAS_HEIGHT + 50) {
            gameState.projectile = null;
            gameState.canFire = true;
            this.nextTurn();
            this.lastTimestamp = null; // Reset for next projectile
            return;
        }

        drawGame();
        requestAnimationFrame((t) => this.animateProjectile(t));
    },

    launchFlamethrower(player) {
        const angleRad = (180 - player.angle) * (Math.PI / 180);
        const beamLength = 200;
        const beamWidth = 35;

        const startX = player.x + Math.cos(angleRad) * 18;
        const startY = player.y - 5 - Math.sin(angleRad) * 18;
        const endX = startX + Math.cos(angleRad) * beamLength;
        const endY = startY - Math.sin(angleRad) * beamLength;

        gameState.beamLine = {
            startX, startY, endX, endY,
            isFlame: true
        };

        gameState.canFire = false;
        player.hasFired = true;
        gameState.hasTargeting = false;

        const hitPlayers = new Set();

        gameState.players.forEach(target => {
            if (!target.alive || target.id === player.id) return;

            const dist = this.distanceToLineSegment(target.x, target.y, startX, startY, endX, endY);
            if (dist <= beamWidth + TANK_WIDTH / 2) {
                hitPlayers.add(target.id);

                if (target.shield) {
                    target.shield = false;
                } else {
                    target.health -= 25;
                    target.burning = 4;
                    if (target.health <= 0) {
                        target.health = 0;
                        target.alive = false;
                        player.money += 200;
                    }
                }
                player.money += 150;
            }
        });

        // Destroy terrain along beam
        for (let i = 0; i <= beamLength; i += 15) {
            const fireX = startX + Math.cos(angleRad) * i;
            const fireY = startY - Math.sin(angleRad) * i;
            destroyTerrain(fireX, fireY, 15);
        }

        drawGame();

        setTimeout(() => {
            gameState.beamLine = null;
            this.checkRoundEnd();
        }, 250);
    },

    launchPlasma(player) {
        const angleRad = (180 - player.angle) * (Math.PI / 180);
        const beamLength = 1500;
        const startX = player.x + Math.cos(angleRad) * 18;
        const startY = player.y - 5 - Math.sin(angleRad) * 18;
        const endX = startX + Math.cos(angleRad) * beamLength;
        const endY = startY - Math.sin(angleRad) * beamLength;

        gameState.beamLine = { startX, startY, endX, endY };
        gameState.canFire = false;
        player.hasFired = true;
        gameState.hasTargeting = false;

        const hitPlayers = new Set();

        gameState.players.forEach(target => {
            if (!target.alive || target.id === player.id) return;

            const dist = this.distanceToLineSegment(target.x, target.y, startX, startY, endX, endY);
            if (dist < TANK_WIDTH / 2 + 10) {
                hitPlayers.add(target.id);

                const directHit = dist < 18;
                let damage = 60;
                let moneyReward = 200;

                if (target.shield) {
                    target.shield = false;
                    damage = 0;
                    let moneyReward = 75;
                }
                if (damage > 0 && !target.shield) {
                    target.health -= damage;
                    if (target.health <= 0) {
                        target.health = 0;
                        target.alive = false;
                        player.money += 200;
                    }
                }
                player.money += moneyReward;
            }
        });

        this.showExplosion(endX, endY, 50);
        destroyTerrain(endX, endY, 50);

        gameState.players.forEach(target => {
            if (!target.alive) return;
            const dist = Math.hypot(target.x - endX, target.y + TANK_HEIGHT / 2 - endY);
            if (dist < 60 && !hitPlayers.has(target.id)) {
                const damage = Math.floor(60 * (1 - dist / 60));
                target.health -= damage;
                if (target.health <= 0) {
                    target.health = 0;
                    target.alive = false;
                    player.money += 200;
                }
            }
        });

        drawGame();
        setTimeout(() => {
            gameState.beamLine = null;
            this.checkRoundEnd();
        }, 300);
    },

    launchEMP(player) {
        const angleRad = (180 - player.angle) * (Math.PI / 180);
        const speed = player.power * 0.12;
        const radius = 50;

        gameState.projectile = {
            x: player.x + Math.cos(angleRad) * 18,
            y: player.y - 5 - Math.sin(angleRad) * 18,
            vx: Math.cos(angleRad) * speed,
            vy: -Math.sin(angleRad) * speed,
            type: 'emp',
            owner: player.id,
            bounces: 0,
            radius: radius
        };

        gameState.canFire = false;
        player.hasFired = true;
        gameState.hasTargeting = false;

        render();
        this.animateProjectile();
    },

    distanceToLineSegment(px, py, x1, y1, x2, y2) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) param = dot / lenSq;
        let xx, yy;

        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
    },

    handleExplosion(x, y, weaponType, ownerId, directHit = null) {
        const weapon = WEAPONS[weaponType];
        const radius = weapon.radius;

        this.showExplosion(x, y, radius);
        destroyTerrain(x, y, radius);
        const owner = gameState.players.find(p => p.id === ownerId);

        gameState.players.forEach(player => {
            if (!player.alive) return;
            const dist = Math.hypot(player.x - x, player.y + TANK_HEIGHT / 2 - y);
            if (dist < radius + TANK_WIDTH / 2) {
                let damage = weapon.damage;
                let moneyReward = 0;

                if (directHit === player || dist < 18) {
                    if (player.shield) {
                        player.shield = false;
                        damage = 0;
                        let moneyReward = 75;
                    } else {
                        damage = weapon.damage;
                        moneyReward = 200;
                    }
                } else if (dist < 35) {
                    damage = Math.floor(damage * 0.8);
                    moneyReward = 100;
                } else {
                    damage = Math.floor(damage * (1 - dist / (radius + TANK_WIDTH / 2)));
                    moneyReward = 0;
                }

                if (damage > 0 && !player.shield) {
                    player.health -= damage;

                    if (weapon.burnDamage && player.id !== ownerId) {
                        player.burning = weapon.burnTurns;
                    }

                    if (weapon.emp && player.id !== ownerId && damage > 0) {
                        player.empDisabled = true;
                        player.empDisabledTurns = 2;
                    }

                    if (player.health <= 0) {
                        player.health = 0;
                        player.alive = false;
                        if (owner) owner.money += 400;
                    }
                }

                if (owner && player.id !== ownerId && moneyReward > 0) {
                    owner.money += moneyReward;
                }
            }
        });

        // Terrain gravity for tanks after explosion
        gameState.players.forEach(player => {
            if (player.alive && !player.isPlane) {
                const newY = getTerrainHeight(player.x) - TANK_HEIGHT;
                if (newY > player.y) {
                    player.y = newY;
                }
            }
        });
        
        gameState.projectile = null;
        setTimeout(() => {
            this.checkRoundEnd();
        }, 500);
    },

    showExplosion(x, y, radius) {
        const container = document.getElementById('explosions');
        if (!container) return;

        const canvas = document.getElementById('gameCanvas');
        const rect = canvas.getBoundingClientRect();
        const scaleX = rect.width / CANVAS_WIDTH;
        const scaleY = rect.height / CANVAS_HEIGHT;

        const explosion = document.createElement('div');
        explosion.className = 'explosion absolute rounded-full';
        explosion.style.left = `${x * scaleX}px`;
        explosion.style.top = `${y * scaleY}px`;
        explosion.style.width = `${radius * 2 * scaleX}px`;
        explosion.style.height = `${radius * 2 * scaleY}px`;
        explosion.style.marginLeft = `${-radius * scaleX}px`;
        explosion.style.marginTop = `${-radius * scaleY}px`;
        explosion.style.background = `radial-gradient(circle, #fef08a 0%, #f97316 35%, #dc2626 65%, transparent 100%)`;
        explosion.style.boxShadow = `0 0 ${radius / 2}px #f97316, inset 0 0 ${radius / 4}px #fef08a`;

        container.appendChild(explosion);
        setTimeout(() => explosion.remove(), 500);
    },

    launchAirstrike(player) {
        player.hasFired = true;

        gameState.canFire = false;
        gameState.shopOpen = false;
        gameState.hasTargeting = false;

        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                const randomX = 100 + Math.random() * (CANVAS_WIDTH - 200);
                const terrainY = getTerrainHeight(randomX);

                this.showExplosion(randomX, terrainY, 45);
                destroyTerrain(randomX, terrainY, 45);

                gameState.players.forEach(p => {
                    if (!p.alive) return;
                    const dist = Math.hypot(p.x - randomX, p.y - terrainY);
                    if (dist < 55) {
                        if (p.shield) {
                            p.shield = false;
                        } else {
                            p.health -= 60;
                            if (p.health <= 0) {
                                p.health = 0;
                                p.alive = false;
                                if (player) player.money += 200;
                            }
                        }
                    }
                });
            }, 200 + i * 250);
        }
        setTimeout(() => this.checkRoundEnd(), 1500);
    },

    checkRoundEnd() {
        const alivePlayers = gameState.players.filter(p => p.alive);
        if (alivePlayers.length <= 1) {
            if (alivePlayers.length === 1) {
                alivePlayers[0].money += 0;
            }
            const playersWithHealth = gameState.players.filter(p => p.health > 0);
            if (playersWithHealth.length <= 1) {
                gameState.phase = 'gameOver';
            } else {
                gameState.phase = 'roundOver';
            }
            render();
        } else {
            gameState.canFire = true;
            this.nextTurn();
        }
    },

    continueNextRound() {
        gameState.round++;
        gameState.players.forEach(p => {
            if (p.health > 0) {
                p.alive = true;
                p.hasFired = false;
                p.empDisabled = false;
                p.empDisabledTurns = 0;
                p.shield = false;
                p.tmp360AimTurns = 0;
            } else {
                p.alive = false;
            }
        });

        const terrainTypes = ['hills', 'mountains', 'canyons', 
                              'ruins', 'valley', 'plateau', 'random'
                                ];
        generateTerrain(terrainTypes[Math.floor(Math.random() * terrainTypes.length)]);
        positionPlayers();

        gameState.currentPlayerIndex = 0;
        while (!gameState.players[gameState.currentPlayerIndex].alive) {
            gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
        }

        gameState.canFire = true;
        gameState.phase = 'playing';
        render();
    },

    continueSkirmish() {
        gameState.players.forEach(p => {
            if (p.alive) {
                p.health = 100;
                if (p.isPlane) p.planeHealth = 100;
                p.hasFired = false;
                p.empDisabled = false;
                p.empDisabledTurns = 0;
                p.shield = false;
                p.tmp360AimTurns = 0;
            }
        });

        const terrainTypes = ['hills', 'mountains', 'canyons', 
                              'ruins', 'valley', 'plateau', 'random'
                                ];
        generateTerrain(terrainTypes[Math.floor(Math.random() * terrainTypes.length)]);
        positionPlayers();

        gameState.currentPlayerIndex = 0;
        while (!gameState.players[gameState.currentPlayerIndex].alive) {
            gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
        }

        gameState.canFire = true;
        gameState.phase = 'playing';
        render();
    },

    goToGameOver() {
        gameState.phase = 'gameOver';
        render();
    },

    nextTurn() {
        const currentPlayer = gameState.players[gameState.currentPlayerIndex];
        
        // Handle burning damage
        if (currentPlayer.burning > 0) {
            if (currentPlayer.isPlane) {
                currentPlayer.planeHealth -= 10;
                if (currentPlayer.planeHealth <= 0) {
                    currentPlayer.planeHealth = 0;
                    currentPlayer.alive = false;
                    this.checkRoundEnd();
                    return;
                }
            } else {
                currentPlayer.health -= 10;
                if (currentPlayer.health <= 0) {
                    currentPlayer.health = 0;
                    currentPlayer.alive = false;
                    this.checkRoundEnd();
                    return;
                }
            }
            currentPlayer.burning--;
        }

        // Handle EMP disable
        if (currentPlayer.empDisabled) {
            currentPlayer.empDisabledTurns--;
            if (currentPlayer.empDisabledTurns <= 0) {
                currentPlayer.empDisabled = false;
            }
        }

        // Handle 360 aim
        if (currentPlayer.tmp360AimTurns > 0) {
            currentPlayer.tmp360AimTurns--;
        }

        // Find next alive player
        let nextIndex = gameState.currentPlayerIndex;
        let attempts = 0;
        do {
            nextIndex = (nextIndex + 1) % gameState.players.length;
            attempts++;
        } while (!gameState.players[nextIndex].alive && attempts < gameState.players.length);

        gameState.currentPlayerIndex = nextIndex;
        gameState.players[nextIndex].hasFired = false;
        render();
    },

    resetGame() {
        gameState = {
            phase: 'setup',
            players: [],
            currentPlayerIndex: 0,
            round: 1,
            terrain: null,
            terrainCtx: null,
            projectile: null,
            canFire: true,
            shopOpen: false,
            explosions: [],
            planes: [],
            bombs: [],
            beamLine: null,
            flameColumn: null,
            trajectoryPoints: [],
            hasTargeting: false,
            empDisabledPlayers: new Set(),
            tmp360AimTurns: 0
        };
        this.selectedColors = new Set();
        render();
    }
};



function createPlayer(color, index) { return {
id: index, color: color, health: 100,
money: DEV_MODE ? 9999 : 200,
gas: 50,
angle: 45,
power: 20,
x: 0,
y: 0,
shield: false, burning: 0,
weapons: ['standard'], selectedWeapon: 'standard', alive: true,
hasFired: false, isPlane: false, planeHealth: 0, empDisabled: false, empDisabledTurns: 0, has360Aim: false, tmp360AimTurns: 0
};
}

function generateTerrain(type) {
    const canvas = document.createElement('canvas');
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;
    const ctx = canvas.getContext('2d');
    
    ctx.fillStyle = 'transparent';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    const points = [];
    const segments = 80;
    
    
    for (let i = 0; i <= segments; i++) {
        const x = (i / segments) * CANVAS_WIDTH;
        const nx = x * 0.01; // Normalized x for Perlin noise
        let y;
        
        // Original terrain types
        switch(type) {
            case 'valley':
                const center = segments / 2;
                const dist = Math.abs(i - center) / center;
                y = CANVAS_HEIGHT - 60 - dist * 200 - Math.random() * 30;
                break;
            case 'plateau':
                if (i > segments * 0.25 && i < segments * 0.75) {
                    y = CANVAS_HEIGHT - 250 - Math.random() * 30;
                } else {
                    y = CANVAS_HEIGHT - 100 - Math.random() * 40;
                }
                break;
            case 'random':
                y = CANVAS_HEIGHT - 120 - Math.random() * 180;
                break;
                
            // New Perlin-based terrains
            // Formula for Perlin Noise: y = CANVAS_HEIGHT - BASE_HEIGHT - (NOISE_VALUE * AMPLITUDE)
            case 'hills': {
                // Tunable parameters
                const baseHeight = 120;
                const wave1Freq = 0.07 + Math.random() * 0.1;    // Try 0.1-0.4
                const wave1Amp = 100 + Math.random() * 50;      // Try 50-150
                const wave2Freq = 0.5;     // Try 0.3-0.8
                const wave2Amp = 60;       // Try 30-90
                const noiseFreq = 4;       // Try 1-4
                const noiseAmp = 150;      // Try 50-200
                
                y = CANVAS_HEIGHT - baseHeight 
                    - Math.sin(i * wave1Freq) * wave1Amp
                    - Math.sin(i * wave2Freq) * wave2Amp
                    + PerlinNoise.noise(nx * noiseFreq, 0) * noiseAmp;
                break;
            }
                            
            case 'mountains':
                // Center of the screen (nx ranges from 0 to 12)
                const mountain_center = 5 + Math.random() * 2; // Middle of your nx range (0-12)
                
                // Distance from center (0 at center, 6 at edges)
                const dist_from_center = Math.abs(nx - mountain_center);
                
                // Gaussian peak formula: e^(-(dist^2) / (2 * spread^2))
                const spread = 2.5; // Controls how wide the mountain is
                const peak = Math.exp(-(dist_from_center * dist_from_center) / (2 * spread * spread));
                
                // Mountain height
                const mountainHeight = 300; // How tall
                
                // Add some small noise for texture
                // Formula for texture: PerlinNoise.noise(nx * FREQUENCY, OFFSET) * AMPLITUDE;
                const texture = PerlinNoise.noise(nx * 4, 0) * 30;
                
                y = CANVAS_HEIGHT - 100 - (peak * mountainHeight) - texture;
                break;
                
            case 'canyons': {
                // Base noise for canyon placement
                const canyonBase = PerlinNoise.noise(nx * 1.5, 0);
                
                // Create deep cuts using absolute value (V-shaped)
                // Shift from -0.5-0.5 to 0-1 range, then amplify
                const canyonDepth = Math.abs(canyonBase - 0.5) * 2; // 0-1, peaks at edges
                
                // Main canyon carving
                const mainCanyon = canyonDepth * 250; // Deep cut
                
                // Add smaller side canyons
                const sideCanyon1 = Math.abs(PerlinNoise.noise(nx * 4, 1) - 0.5) * 100;
                const sideCanyon2 = Math.abs(PerlinNoise.noise(nx * 8, 2) - 0.5) * 50;
                
                // Keep some flat areas (plateaus)
                const plateau = canyonDepth < 0.3 ? 0 : 1; // Only cut where canyon is deep
                
                // Combine
                const canyon = (mainCanyon + sideCanyon1 + sideCanyon2) * plateau;
                
                y = CANVAS_HEIGHT - 100 - canyon;
                break;
            }
 
            case 'perlin-ruins': {
                // Main ruin structure - tangent creates sharp breaks
                const ruinMain = Math.tan(nx * 3, 2.5) * 80;
                const extraDetail = Math.abs(Math.sin(i * 0.15)) * 180 - Math.random() * 40;

                y = CANVAS_HEIGHT - 120 - ruinMain - extraDetail
                break;
            }

            case 'random': {
                y = CANVAS_HEIGHT - 120 - Math.random() * 180;
            }
                
        }
        
        // Clamp height to ensure terrain stays within visible range
        y = Math.max(80, Math.min(CANVAS_HEIGHT - 40, y));
        points.push({ x, y });
    }
    
    // Apply smoothing passes (different amounts for different terrain types)
    let smoothingPasses = 4; // Default for original terrains
    
    // Less smoothing for jagged Perlin terrains to preserve detail
    if (type.startsWith('perlin-')) {
        smoothingPasses = 2;
    }
    
    for (let pass = 0; pass < smoothingPasses; pass++) {
        for (let i = 1; i < points.length - 1; i++) {
            points[i].y = (points[i-1].y + points[i].y + points[i+1].y) / 3;
        }
    }
    
    // Draw the terrain with gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
    gradient.addColorStop(0, '#6b7280');
    gradient.addColorStop(0.3, '#4b5563');
    gradient.addColorStop(1, '#1f2937');
    
    ctx.beginPath();
    ctx.moveTo(0, CANVAS_HEIGHT);
    points.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT);
    ctx.closePath();
    ctx.fillStyle = gradient;
    ctx.fill();
    
    // Draw terrain outline
    ctx.strokeStyle = '#374151';
    ctx.lineWidth = 2;
    ctx.beginPath();
    points.forEach((p, i) => {
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
    });
    ctx.stroke();
    
    // Add texture details
    for (let i = 0; i < points.length - 1; i++) {
        if (Math.random() > 0.85) {
            ctx.strokeStyle = '#4b5563';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(points[i].x, points[i].y);
            ctx.lineTo(points[i].x + 8 + Math.random() * 12, 
                       points[i].y + 15 + Math.random() * 15);
            ctx.stroke();
        }
    }
    
    gameState.terrain = canvas;
    gameState.terrainCtx = ctx;
    
    return points;
}

function getTerrainHeight(x) {
if (!gameState.terrain) return CANVAS_HEIGHT - 120;
 
const ctx = gameState.terrainCtx;
const ix = Math.floor(Math.max(0, Math.min(CANVAS_WIDTH - 1, x))); const imageData = ctx.getImageData(ix, 0, 1, CANVAS_HEIGHT);

for (let y = 0; y < CANVAS_HEIGHT; y++) { const alpha = imageData.data[y * 4 + 3]; if (alpha > 0) return y;
}
return CANVAS_HEIGHT - 60;
}

function positionPlayers() {
if (!gameState.terrain) return; gameState.players.forEach((player, index) => {
player.x = 150 + (index * (CANVAS_WIDTH / gameState.players.length)); if (!player.isPlane) {
player.y = getTerrainHeight(player.x) - TANK_HEIGHT;
} else {
player.y = 100;
}
});
}

function destroyTerrain(x, y, radius) { const ctx = gameState.terrainCtx;
ctx.globalCompositeOperation = 'destination-out'; ctx.fillStyle = 'rgba(0,0,0,1)';
ctx.beginPath();
ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill();
ctx.globalCompositeOperation = 'source-over';
}

function calculateTrajectory(startX, startY, angle, power) { const points = [];
const angleRad = (180 - angle) * (Math.PI / 180); const speed = power * 0.12;

let x = startX; let y = startY;
let vx = Math.cos(angleRad) * speed; let vy = -Math.sin(angleRad) * speed;
 
for (let i = 0; i < 300; i++) { vy += 0.12;
x += vx; y += vy;

if (i % 3 === 0) {
points.push({ x, y });
}

const terrainY = getTerrainHeight(x); if (y >= terrainY) break;

if (x < -50 || x > CANVAS_WIDTH + 50 || y > CANVAS_HEIGHT + 50) break;
}

return points;
}

function render() {
const app = document.getElementById('app');

if (gameState.phase === 'setup') { renderSetup(app);
} else if (gameState.phase === 'playing') { renderGame(app);
} else if (gameState.phase === 'roundOver') { renderRoundOver(app);
} else if (gameState.phase === 'gameOver') { renderGameOver(app);
}
}

function renderSetup(container) { container.innerHTML = `
<div class="h-full flex flex-col items-center justify-center p-8">
<h1 class="text-6xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-purple-500 to-pink-500 mb-2 drop-shadow-lg">
‚öî TANK WARS ‚öî
</h1>
<p class="text-slate-400 text-lg mb-8">Multiplayer Artillery Combat</p>

<div class="bg-slate-900/90 rounded-3xl p-10 border-2 border-purple-500/50 max-w-2xl w-full backdrop-blur-sm">
<h2 class="text-3xl font-bold text-white mb-8 text-center">Select Commanders</h2>
 
<div class="grid grid-cols-2 gap-4 mb-10">
${['red', 'blue', 'green', 'yellow'].map(color => `
<button onclick="window.tankWars.togglePlayer('${color}')" id="btn-${color}"
class="p-6 rounded-2xl border-3 transition-all duration-200 flex items-center gap-3 hover:scale-105"
style="border-color: ${COLORS[color].primary}; background: linear-gradient(135deg,
${COLORS[color].dark}40, ${COLORS[color].dark}20);"
>
<div class="w-12 h-8 rounded-lg" style="background: linear-gradient(135deg,
${COLORS[color].primary}, ${COLORS[color].light}); box-shadow: 0 0 15px
${COLORS[color].primary}80;"></div>
<span class="text-white font-black capitalize text-lg">${color}</span>
<span class="ml-auto text-3xl" id="check-${color}">‚óã</span>
</button>
`).join('')}
</div>

<button onclick="window.tankWars.startGame()" id="startBtn"
class="w-full py-4 bg-gradient-to-r from-cyan-500 via-purple-600 to-pink-500 hover:from-cyan-400 hover:via-purple-500 hover:to-pink-400 text-white font-black text-2xl rounded-2xl transition-all duration-200 disabled:opacity-40 disabled:cursor-not-allowed shadow-lg hover:shadow-2xl"
disabled
>
‚ñ∂ START BATTLE
</button>

<p class="text-slate-400 text-center mt-6 text-sm">Select 2-4 commanders to begin combat</p>
</div>
</div>
`;
}

function renderGame(container) {
const currentPlayer = gameState.players[gameState.currentPlayerIndex]; const alivePlayers = gameState.players.filter(p => p.alive).length;

container.innerHTML = `
 
<div class="h-full flex flex-col">
<!-- Compact Header HUD -->
<div class="flex justify-between items-center px-4 py-2 bg-gradient-to-r from-slate-900/95 to-slate-800/95 border-b-2 border-purple-500/30 gap-2">
<!-- Player Status Pills -->
<div class="flex gap-1 flex-wrap min-w-0">
${gameState.players.map((p, i) => `
<div class="flex items-center gap-1 px-2 py-1 rounded text-xs transition-all whitespace-nowrap"
style="background: linear-gradient(135deg, ${COLORS[p.color].dark}80,
${COLORS[p.color].dark}40); border: ${i === gameState.currentPlayerIndex ? '2px solid white' : 'none'};">
<span class="text-white font-bold">${p.alive ? 'üî´' : 'üíÄ'}</span>
<span class="text-yellow-300 font-bold">${p.health}HP</span>
<span class="text-cyan-300 text-xs">üí∞${p.money}</span>
</div>
`).join('')}
</div>

<!-- Center Controls -->
<div class="flex items-center gap-2">
<!-- Weapon Select -->
<select onchange="window.tankWars.selectWeapon(this.value)" class="bg-slate-700 text-white px-2 py-1 rounded text-xs border border-slate-600 font-semibold">
${currentPlayer.weapons.map(w => `
<option value="${w}" 
        ${currentPlayer.selectedWeapon === w ? 'selected' : ''}
        ${currentPlayer.empDisabled && (w === 'flamethrower' || w
=== 'plasma' || w === 'airstrike' || w === 'guided' || w === 'emp') ? 'disabled' : ''}>${WEAPONS[w].name}</option>
`).join('')}
</select>

<!-- Shop Button -->
<button onclick="window.tankWars.toggleShop()" class="px-2 py-1 bg-gradient-to-r from-yellow-600 to-orange-600 hover:from-yellow-500 hover:to-orange-500 text-white font-black rounded text-xs shadow-lg">
üõí
</button>
</div>

<!-- Round Badge -->
<div class="text-white font-black text-xs bg-purple-900/60 px-2 py-1 rounded">R${gameState.round}</div>
</div>
 
<!-- Game Canvas -->
<div class="flex-1 relative overflow-hidden flex items-center justify-center" id="gameArea">
<canvas id="gameCanvas" width="${CANVAS_WIDTH}" height="${CANVAS_HEIGHT}" style="width: 100%; height: 100%; display: block;"></canvas>
<div id="explosions" class="absolute inset-0 pointer-events-none"></div>
</div>

<!-- Compact Control Panel -->
<div class="bg-gradient-to-r from-slate-900/95 to-slate-800/95 border-t-2 border-purple-500/30 p-2">
<div class="flex items-center justify-center gap-2 flex-wrap text-xs">
<!-- Current Player -->
<div class="bg-slate-800/60 px-2 py-1 rounded border border-slate-700 font-bold capitalize" style="color: ${COLORS[currentPlayer.color].primary};">
${currentPlayer.color} ${currentPlayer.isPlane ? '‚úà' : 'üî´'}
</div>

<!-- Angle Control -->
<div class="flex items-center gap-1">
<button onclick="window.tankWars.adjustAngle(-${ANGLE_INCREMENT})" class="...">‚àí</button>
<span class="...">${currentPlayer.angle}¬∞</span>
<button onclick="window.tankWars.adjustAngle(${ANGLE_INCREMENT})" class="...">+</button>
</div>

<!-- Power Control -->
<div class="flex items-center gap-1">
<button onclick="window.tankWars.adjustPower(-${POWER_INCREMENT})" class="...">‚àí</button>
<span class="...">${currentPlayer.power}</span>
<button onclick="window.tankWars.adjustPower(${POWER_INCREMENT})" class="...">+</button>
</div>

<!-- Movement & Fire -->
${!currentPlayer.isPlane && !currentPlayer.empDisabled ? `
<button onclick="window.tankWars.moveTank(-1)" class="w-5 h-5 bg-slate-700 hover:bg-slate-600 rounded text-white text-xs" ${currentPlayer.gas < 5 ? 'disabled' : ''}>‚óÄ</button>
 
<button onclick="window.tankWars.moveTank(1)" class="w-5 h-5 bg-slate-700 hover:bg-slate-600 rounded text-white text-xs" ${currentPlayer.gas < 5 ? 'disabled' : ''}>‚ñ∂</button>
` : currentPlayer.isPlane ? `
<button onclick="window.tankWars.movePlane(-1)" class="w-5 h-5 bg-slate-700 hover:bg-slate-600 rounded text-white text-xs">‚óÄ</button>
<button onclick="window.tankWars.movePlane(1)" class="w-5 h-5 bg-slate-700 hover:bg-slate-600 rounded text-white text-xs">‚ñ∂</button>
` : ''}

<!-- Fire Button -->
<button onclick="window.tankWars.fire()" class="px-3 py-1 bg-gradient-to-r from-red-600 via-orange-600 to-yellow-600 hover:from-red-500 hover:via-orange-500
hover:to-yellow-500 text-white font-black rounded text-xs shadow-lg ${!gameState.canFire ? 'opacity-50 cursor-not-allowed' : ''}" ${!gameState.canFire ? 'disabled' : ''}>
üî• FIRE
</button>
</div>
</div>

<!-- Shop Modal -->
${gameState.shopOpen ? `
<div class="absolute inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-end">
<div class="shop-modal bg-gradient-to-t from-slate-900 to-slate-800 w-full max-h-96 rounded-t-3xl border-t-2 border-purple-500 overflow-auto p-4">
<div class="flex justify-between items-center mb-3">
<h3 class="text-lg font-black text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-orange-500">üõí SHOP</h3>
<button onclick="window.tankWars.toggleShop()" class="text-slate-400 hover:text-white text-xl">‚úï</button>
</div>

<div class="mb-4">
<h4 class="text-xs font-black text-slate-300 mb-2">‚öô UPGRADES</h4>
<div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-2 mb-4">
<button onclick="window.tankWars.buyItem('plane')" class="px-2 py-2 rounded-lg text-white text-xs font-bold transition-all disabled:opacity-30 disabled:cursor-not-allowed
${currentPlayer.isPlane ? 'border-2 border-lime-400 bg-blue-700' : 'bg-blue-700/60 hover:bg-blue-700 border border-blue-600'}" ${currentPlayer.money < 2000 &&
!currentPlayer.isPlane ? 'disabled' : ''}>‚úà PLANE<br>$2000</button>
</div>
</div>

<h4 class="text-xs font-black text-slate-300 mb-2">üõ† CONSUMABLES</h4>
 
<div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-9 gap-2 mb-4">
<button onclick="window.tankWars.buyItem('gas')" class="px-2 py-2 bg-blue-600/80 hover:bg-blue-600 rounded-lg text-white text-xs font-bold border border-blue-500 transition-all disabled:opacity-30 disabled:cursor-not-allowed" ${currentPlayer.money < 50 || currentPlayer.empDisabled ? 'disabled' : ''}>‚õΩ+30<br>$50</button>
<button onclick="window.tankWars.buyItem('health')" class="px-2 py-2 bg-green-600/80 hover:bg-green-600 rounded-lg text-white text-xs font-bold border border-green-500 transition-all disabled:opacity-30 disabled:cursor-not-allowed"
${currentPlayer.money < 75 || (currentPlayer.isPlane ? currentPlayer.planeHealth >= 100 : currentPlayer.health >= 100) ? 'disabled' : ''}>‚ù§+30<br>$75</button>
<button onclick="window.tankWars.buyItem('shield')" class="px-2 py-2 bg-cyan-600/80 hover:bg-cyan-600 rounded-lg text-white text-xs font-bold border border-cyan-500 transition-all disabled:opacity-30 disabled:cursor-not-allowed"
${currentPlayer.money < 150 || currentPlayer.shield || currentPlayer.empDisabled ? 'disabled' : ''}>üõ° SHIELD<br>$150</button>
<button onclick="window.tankWars.buyItem('360aim')" class="px-2 py-2
bg-pink-600/80 hover:bg-pink-600 rounded-lg text-white text-xs font-bold border border-pink-500 transition-all disabled:opacity-30 disabled:cursor-not-allowed" ${currentPlayer.money < 150 ? 'disabled' : ''}>üéØ 360¬∞<br>$150</button>
<button onclick="window.tankWars.buyItem('targeting')" class="px-2 py-2 bg-indigo-600/80 hover:bg-indigo-600 rounded-lg text-white text-xs font-bold border border-indigo-500 transition-all disabled:opacity-30 disabled:cursor-not-allowed"
${currentPlayer.money < 250 || currentPlayer.selectedWeapon === 'sniper' ? 'disabled' : ''}>üéØ
TARGET<br>$250</button>
<button onclick="window.tankWars.buyItem('luckybox1')" class="px-2 py-2 bg-amber-600/80 hover:bg-amber-600 rounded-lg text-white text-xs font-bold border border-amber-500 transition-all disabled:opacity-30 disabled:cursor-not-allowed"
${currentPlayer.money < 50 ? 'disabled' : ''}>üéÅ LUCKY BOX I<br>$50</button>
<button onclick="window.tankWars.buyItem('luckybox2')" class="px-2 py-2 bg-amber-500/80 hover:bg-amber-500 rounded-lg text-white text-xs font-bold border border-amber-400 transition-all disabled:opacity-30 disabled:cursor-not-allowed"
${currentPlayer.money < 125 ? 'disabled' : ''}>üéÅ LUCKY BOX II<br>$125</button>
<button onclick="window.tankWars.buyItem('luckybox3')" class="px-2 py-2 bg-amber-400/80 hover:bg-amber-400 rounded-lg text-white text-xs font-bold border border-amber-300 transition-all disabled:opacity-30 disabled:cursor-not-allowed"
${currentPlayer.money < 250 ? 'disabled' : ''}>üéÅ LUCKY BOX III<br>$250</button>
</div>

<h4 class="text-xs font-black text-slate-300 mb-2">üí• WEAPONS</h4>
<div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-9 gap-2">
<button onclick="window.tankWars.buyItem('medium')" class="px-2 py-2 rounded-lg text-white text-xs font-bold transition-all disabled:opacity-30 disabled:cursor-not-allowed
${currentPlayer.weapons.includes('medium') ? 'border-2 border-lime-400 bg-orange-600' :
 
'bg-orange-600/60 hover:bg-orange-600 border border-orange-500'}" ${currentPlayer.money < 150 && !currentPlayer.weapons.includes('medium') ? 'disabled' : ''}>üí•MEDIUM<br>$150</button>
<button onclick="window.tankWars.buyItem('large')" class="px-2 py-2 rounded-lg text-white text-xs font-bold transition-all disabled:opacity-30 disabled:cursor-not-allowed
${currentPlayer.weapons.includes('large') ? 'border-2 border-lime-400 bg-orange-700' :
'bg-orange-700/60 hover:bg-orange-700 border border-orange-600'}" ${currentPlayer.money < 250 && !currentPlayer.weapons.includes('large') ? 'disabled' : ''}>‚òÑÔ∏èLARGE<br>$250</button>
<button onclick="window.tankWars.buyItem('cannonball')" class="px-2 py-2 rounded-lg text-white text-xs font-bold transition-all disabled:opacity-30
disabled:cursor-not-allowed ${currentPlayer.weapons.includes('cannonball') ? 'border-2 border-lime-400 bg-slate-600' : 'bg-slate-600/60 hover:bg-slate-600 border border-slate-500'}"
${currentPlayer.money < 200 && !currentPlayer.weapons.includes('cannonball') ? 'disabled' : ''}>‚ö´BOUNCE<br>$200</button>
<button onclick="window.tankWars.buyItem('sniper')" class="px-2 py-2 rounded-lg text-white text-xs font-bold transition-all disabled:opacity-30 disabled:cursor-not-allowed
${currentPlayer.weapons.includes('sniper') ? 'border-2 border-lime-400 bg-purple-600' :
'bg-purple-600/60 hover:bg-purple-600 border border-purple-500'}" ${currentPlayer.money < 300 && !currentPlayer.weapons.includes('sniper') ? 'disabled' : ''}>üéØSNIPE<br>$300</button>
<button onclick="window.tankWars.buyItem('flamethrower')" class="px-2 py-2 rounded-lg text-white text-xs font-bold transition-all disabled:opacity-30
disabled:cursor-not-allowed ${currentPlayer.weapons.includes('flamethrower') ? 'border-2 border-lime-400 bg-red-600' : 'bg-red-600/60 hover:bg-red-600 border border-red-500'}"
${currentPlayer.money < 350 && !currentPlayer.weapons.includes('flamethrower') ? 'disabled' : ''}>üî•FLAME<br>$350</button>
<button onclick="window.tankWars.buyItem('guided')" class="px-2 py-2 rounded-lg text-white text-xs font-bold transition-all disabled:opacity-30 disabled:cursor-not-allowed
${currentPlayer.weapons.includes('guided') ? 'border-2 border-lime-400 bg-teal-600' :
'bg-teal-600/60 hover:bg-teal-600 border border-teal-500'}" ${currentPlayer.money < 400 &&
!currentPlayer.weapons.includes('guided') ? 'disabled' : ''}>üéÆGUIDED<br>$400</button>
<button onclick="window.tankWars.buyItem('plasma')" class="px-2 py-2 rounded-lg text-white text-xs font-bold transition-all disabled:opacity-30 disabled:cursor-not-allowed
${currentPlayer.weapons.includes('plasma') ? 'border-2 border-lime-400 bg-indigo-600' :
'bg-indigo-600/60 hover:bg-indigo-600 border border-indigo-500'}" ${currentPlayer.money < 450 && !currentPlayer.weapons.includes('plasma') ? 'disabled' : ''}>‚ö°PLASMA<br>$450</button>
<button onclick="window.tankWars.buyItem('atomic')" class="px-2 py-2 rounded-lg text-white text-xs font-bold transition-all disabled:opacity-30 disabled:cursor-not-allowed
${currentPlayer.weapons.includes('atomic') ? 'border-2 border-lime-400 bg-lime-600' :
'bg-lime-600/60 hover:bg-lime-600 border border-lime-500'}" ${currentPlayer.money < 500 &&
!currentPlayer.weapons.includes('atomic') ? 'disabled' : ''}>‚ò¢Ô∏èATOMIC<br>$500</button>
<button onclick="window.tankWars.buyItem('emp')" class="px-2 py-2 rounded-lg text-white text-xs font-bold transition-all disabled:opacity-30 disabled:cursor-not-allowed
${currentPlayer.weapons.includes('emp') ? 'border-2 border-lime-400 bg-purple-700' :
'bg-purple-700/60 hover:bg-purple-700 border border-purple-600'}" ${currentPlayer.money < 550 && !currentPlayer.weapons.includes('emp') ? 'disabled' : ''}>‚ö°EMP<br>$550</button>
 
<button onclick="window.tankWars.buyItem('airstrike')" class="px-2 py-2 rounded-lg text-white text-xs font-bold transition-all disabled:opacity-30 disabled:cursor-not-allowed
${currentPlayer.weapons.includes('airstrike') ? 'border-2 border-lime-400 bg-rose-700' :
'bg-rose-700/60 hover:bg-rose-700 border border-rose-600'}" ${currentPlayer.money < 600 &&
!currentPlayer.weapons.includes('airstrike') ? 'disabled' : ''}>‚úàSTRIKE<br>$600</button>
</div>
</div>
</div>
` : ''}
</div>
`;

setTimeout(() => drawGame(), 0);
}

function renderRoundOver(container) {
const alivePlayers = gameState.players.filter(p => p.alive);
const rankings = [...gameState.players].sort((a, b) => b.money - a.money);

container.innerHTML = `
<div class="h-full flex flex-col items-center justify-center p-8 bg-gradient-to-b from-indigo-950 via-slate-900 to-slate-950">
<h1 class="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-purple-500 to-pink-500 mb-4 drop-shadow-lg">
üèÅ ROUND ${gameState.round} COMPLETE üèÅ
</h1>

<div class="bg-slate-900/90 rounded-3xl p-8 border-2 border-purple-500/50 w-full max-w-2xl backdrop-blur-sm mb-8">
<h2 class="text-2xl font-black text-white mb-6 text-center">üìä ROUND
STANDINGS</h2>

<div class="space-y-3 mb-8">
${rankings.map((p, i) => `
<div class="flex items-center justify-between p-4 rounded-xl" style="background: linear-gradient(135deg, ${COLORS[p.color].dark}60, ${COLORS[p.color].dark}30); border-left: 4px solid ${COLORS[p.color].primary};">
<div class="flex items-center gap-4">
<div class="text-3xl font-black w-10 text-center">${i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i
=== 2 ? 'ü•â' : '4'}</div>
<div>
<div class="text-lg font-black text-white capitalize">${p.color} Commander
${p.isPlane ? '‚úà' : ''}</div>
 
<div class="text-sm text-slate-300">HP: ${p.health} | Status: ${!p.alive ? 'üíÄ ELIMINATED' : '‚úÖ ALIVE'}</div>
</div>
</div>
<div class="text-right">
<div class="text-3xl font-black text-yellow-300">$${p.money}</div>
<div class="text-xs text-slate-400">Balance</div>
</div>
</div>
`).join('')}
</div>

<div class="flex gap-4 flex-wrap">
${alivePlayers.length > 1 ? `
<button onclick="window.tankWars.continueNextRound()" class="flex-1 min-w-48 py-4 bg-gradient-to-r from-cyan-500 via-purple-600 to-pink-500 hover:from-cyan-400
hover:via-purple-500 hover:to-pink-400 text-white font-black text-xl rounded-2xl transition-all shadow-lg hover:shadow-xl hover:scale-105">
‚ñ∂ NEXT ROUND
</button>
<button onclick="window.tankWars.continueSkirmish()" class="flex-1 min-w-48 py-4 bg-gradient-to-r from-green-500 via-emerald-600 to-teal-600 hover:from-green-400
hover:via-emerald-500 hover:to-teal-500 text-white font-black text-xl rounded-2xl transition-all shadow-lg hover:shadow-xl hover:scale-105">
üîÑ CONTINUE SKIRMISH
</button>
<button onclick="window.tankWars.continueSkirmish()" class="flex-1 min-w-48 py-4 bg-gradient-to-r from-indigo-500 via-blue-600 to-cyan-600 hover:from-indigo-400
hover:via-blue-500 hover:to-cyan-500 text-white font-black text-xl rounded-2xl transition-all shadow-lg hover:shadow-xl hover:scale-105">
‚è≠ CONTINUE
</button>
` : `
<button onclick="window.tankWars.goToGameOver()" class="flex-1 min-w-48 py-4 bg-gradient-to-r from-yellow-500 via-orange-600 to-red-600 hover:from-yellow-400
hover:via-orange-500 hover:to-red-500 text-white font-black text-xl rounded-2xl transition-all shadow-lg hover:shadow-xl hover:scale-105">
üèÜ FINAL RESULTS
</button>
`}
<button onclick="window.tankWars.resetGame()" class="py-4 px-8 bg-gradient-to-r from-slate-600 via-slate-700 to-slate-800 hover:from-slate-500 hover:via-slate-600
hover:to-slate-700 text-white font-black text-xl rounded-2xl transition-all shadow-lg hover:shadow-xl">
 
üîô RESET
</button>
</div>
</div>
</div>
`;
}

function renderGameOver(container) {
const winner = gameState.players.find(p => p.alive) || gameState.players.reduce((a, b) => a.money > b.money ? a : b);

container.innerHTML = `
<div class="h-full flex flex-col items-center justify-center p-8 bg-gradient-to-b from-indigo-950 via-slate-900 to-slate-950">
<h1 class="text-7xl font-black text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 via-orange-500 to-red-500 mb-6 drop-shadow-lg">
üèÜ GAME OVER üèÜ
</h1>

<div class="bg-slate-800/90 rounded-3xl p-12 border-4 mb-12 backdrop-blur-sm" style="border-color: ${COLORS[winner.color].primary};">
<div class="text-center">
<div class="text-9xl mb-6 drop-shadow-lg">ü•á</div>
<div class="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-yellow-300 to-orange-400 capitalize mb-4">${winner.color} COMMANDER VICTORIOUS!</div>
<div class="text-3xl font-black text-yellow-300">Final Balance: $${winner.money}</div>
</div>
</div>

<div class="flex gap-6 mb-12 flex-wrap justify-center">
${gameState.players.sort((a, b) => b.money - a.money).map((p, i) => `
<div class="bg-slate-800/70 rounded-2xl p-6 text-center border-2" style="border-color:
${COLORS[p.color].primary}40;">
<div class="text-5xl mb-3">${i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '4'}</div>
<div class="text-2xl font-black text-white capitalize">${p.color}</div>
<div class="text-xl font-bold" style="color:
${COLORS[p.color].primary};">$${p.money}</div>
</div>
`).join('')}
</div>
 
<button onclick="window.tankWars.resetGame()" class="px-16 py-6 bg-gradient-to-r from-purple-600 via-pink-600 to-red-600 hover:from-purple-500 hover:via-pink-500 hover:to-red-500 text-white font-black text-2xl rounded-2xl transition-all shadow-xl hover:shadow-2xl hover:scale-105">
‚ñ∂ PLAY AGAIN
</button>
</div>
`;
}

function drawGame() {
const canvas = document.getElementById('gameCanvas'); if (!canvas) return;

const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;

const skyGradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT); skyGradient.addColorStop(0, '#0f172a');
skyGradient.addColorStop(0.3, '#1e293b'); skyGradient.addColorStop(0.7, '#334155');
skyGradient.addColorStop(1, '#475569'); ctx.fillStyle = skyGradient;
ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

for (let i = 0; i < 50; i++) {
ctx.fillStyle = 'rgba(255,255,255,' + (Math.sin(i) * 0.3 + 0.5) + ')'; const x = (i * 23) % CANVAS_WIDTH;
const y = (i * 17) % (CANVAS_HEIGHT * 0.3);
ctx.beginPath();
ctx.arc(x, y, 1 + (i % 2), 0, Math.PI * 2); ctx.fill();
}

if (gameState.terrain) { ctx.drawImage(gameState.terrain, 0, 0);
}

const currentPlayer = gameState.players[gameState.currentPlayerIndex]; if (currentPlayer && currentPlayer.alive) {
drawTrajectoryArrow(ctx, currentPlayer.x, currentPlayer.y - 2, currentPlayer.angle, currentPlayer.power);

// Draw trajectory points if targeting is active
 
if (gameState.hasTargeting) {
const points = calculateTrajectory(currentPlayer.x, currentPlayer.y - 2, currentPlayer.angle, currentPlayer.power);
ctx.fillStyle = 'rgba(74, 222, 128, 0.6)'; points.forEach((p, i) => {
if (i % 2 === 0) {
ctx.beginPath();
ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill();
}
});
}
}

gameState.players.forEach(player => { if (!player.alive) return;
if (player.isPlane) { drawPlane(ctx, player);
} else {
drawTank(ctx, player);
}
});

if (gameState.projectile) { drawProjectile(ctx, gameState.projectile);
}

if (gameState.beamLine) { drawBeamLine(ctx, gameState.beamLine);
}
}

function drawTrajectoryArrow(ctx, fromX, fromY, angle, power) { const angleRad = (180 - angle) * (Math.PI / 180);
const arrowLength = power * 1.8;
const endX = fromX + Math.cos(angleRad) * arrowLength; const endY = fromY - Math.sin(angleRad) * arrowLength;

ctx.strokeStyle = 'rgba(255, 200, 100, 0.5)';
ctx.lineWidth = 2;
ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(fromX, fromY); ctx.lineTo(endX, endY);
 
ctx.stroke(); ctx.setLineDash([]);

const arrowSize = 8;
const arrowAngle = Math.PI / 6;

ctx.fillStyle = 'rgba(255, 200, 100, 0.8)'; ctx.beginPath();
ctx.moveTo(endX, endY);
ctx.lineTo(endX - Math.cos(angleRad - arrowAngle) * arrowSize, endY + Math.sin(angleRad
- arrowAngle) * arrowSize);
ctx.lineTo(endX - Math.cos(angleRad + arrowAngle) * arrowSize, endY + Math.sin(angleRad
+ arrowAngle) * arrowSize); ctx.closePath(); ctx.fill();
}

function drawTank(ctx, player) {
const colors = COLORS[player.color]; const x = player.x;
const y = player.y; ctx.save();
ctx.shadowColor = colors.primary + '80'; ctx.shadowBlur = 8;
ctx.shadowOffsetX = 0;
ctx.shadowOffsetY = 2;

ctx.fillStyle = colors.dark;
ctx.fillRect(x - TANK_WIDTH/2, y, TANK_WIDTH, TANK_HEIGHT);

const grad = ctx.createLinearGradient(x - TANK_WIDTH/2, y, x - TANK_WIDTH/2, y + TANK_HEIGHT);
grad.addColorStop(0, colors.primary); grad.addColorStop(0.5, colors.light); grad.addColorStop(1, colors.primary); ctx.fillStyle = grad;
ctx.fillRect(x - TANK_WIDTH/2 + 2, y + 2, TANK_WIDTH - 4, TANK_HEIGHT - 4);

ctx.fillStyle = colors.dark; ctx.beginPath();
ctx.arc(x, y - 2, 7, 0, Math.PI * 2); ctx.fill();
 
ctx.fillStyle = colors.light; ctx.beginPath();
ctx.arc(x, y - 2, 5, 0, Math.PI * 2); ctx.fill();

const barrelLength = 20;
const angleRad = (180 - player.angle) * (Math.PI / 180); const barrelEndX = x + Math.cos(angleRad) * barrelLength; const barrelEndY = y - 2 - Math.sin(angleRad) * barrelLength;

ctx.strokeStyle = colors.dark; ctx.lineWidth = 5; ctx.lineCap = 'round'; ctx.beginPath(); ctx.moveTo(x, y - 2);
ctx.lineTo(barrelEndX, barrelEndY); ctx.stroke();

ctx.strokeStyle = colors.light; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(x, y - 2);
ctx.lineTo(barrelEndX, barrelEndY); ctx.stroke();

ctx.fillStyle = '#1f2937';
ctx.fillRect(x - TANK_WIDTH/2 - 1, y + TANK_HEIGHT - 4, TANK_WIDTH + 2, 4);

ctx.fillStyle = colors.primary; for (let i = 0; i < 4; i++) {
ctx.fillRect(x - TANK_WIDTH/2 + 2 + i * 5, y + TANK_HEIGHT - 3, 3, 3);
}

if (player.shield) { ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 2;
ctx.setLineDash([4, 3]); ctx.beginPath();
ctx.arc(x, y, TANK_WIDTH/2 + 8, 0, Math.PI * 2); ctx.stroke();
ctx.setLineDash([]);
}
 
if (player.empDisabled) { ctx.strokeStyle = '#a855f7'; ctx.lineWidth = 3;
ctx.setLineDash([6, 4]); ctx.beginPath();
ctx.arc(x, y, TANK_WIDTH/2 + 14, 0, Math.PI * 2); ctx.stroke();
ctx.setLineDash([]);
}

if (player.burning > 0) { ctx.fillStyle = '#f97316'; ctx.globalAlpha = 0.7; for (let i = 0; i < 3; i++) {
const fx = x - 12 + Math.random() * 24; const fy = y - 8 - Math.random() * 15; ctx.beginPath();
ctx.arc(fx, fy, 4 + Math.random() * 6, 0, Math.PI * 2); ctx.fill();
}
ctx.globalAlpha = 1;
}

ctx.fillStyle = '#1f2937'; ctx.fillRect(x - 16, y - 20, 32, 5);
ctx.strokeStyle = '#374151';
ctx.lineWidth = 1;
ctx.strokeRect(x - 16, y - 20, 32, 5);

ctx.fillStyle = player.health > 50 ? '#22c55e' : player.health > 25 ? '#eab308' : '#ef4444'; ctx.fillRect(x - 16, y - 20, (player.health / 100) * 32, 5);

ctx.restore();
}

function drawPlane(ctx, player) {
const colors = COLORS[player.color]; const x = player.x;
const y = player.y; ctx.save();
ctx.shadowColor = colors.primary + '80'; ctx.shadowBlur = 12;
 
ctx.shadowOffsetX = 0;
ctx.shadowOffsetY = 2;

// Fuselage
ctx.fillStyle = colors.dark; ctx.beginPath();
ctx.ellipse(x, y, 22, 8, 0, 0, Math.PI * 2); ctx.fill();

const grad = ctx.createLinearGradient(x - 22, y, x + 22, y); grad.addColorStop(0, colors.light); grad.addColorStop(0.5, colors.primary); grad.addColorStop(1, colors.light);
ctx.fillStyle = grad; ctx.beginPath();
ctx.ellipse(x, y, 20, 6, 0, 0, Math.PI * 2); ctx.fill();

// Cockpit
ctx.fillStyle = colors.light; ctx.beginPath();
ctx.arc(x - 8, y - 2, 4, 0, Math.PI * 2); ctx.fill();

// Wings
ctx.fillStyle = colors.primary; ctx.beginPath(); ctx.moveTo(x - 5, y);
ctx.lineTo(x - 28, y - 4);
ctx.lineTo(x - 25, y + 2); ctx.closePath(); ctx.fill();

ctx.beginPath(); ctx.moveTo(x + 5, y); ctx.lineTo(x + 28, y - 4);
ctx.lineTo(x + 25, y + 2); ctx.closePath();
ctx.fill();

// Tail
ctx.fillStyle = colors.dark; ctx.beginPath(); ctx.moveTo(x + 20, y);
 
ctx.lineTo(x + 30, y - 2);
ctx.lineTo(x + 30, y + 2); ctx.closePath();
ctx.fill();

// Cannon (always pointing down for plane) const cannonLength = 18;
const cannonEndX = x;
const cannonEndY = y + cannonLength;

ctx.strokeStyle = colors.dark; ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.beginPath(); ctx.moveTo(x, y);
ctx.lineTo(cannonEndX, cannonEndY); ctx.stroke();

ctx.strokeStyle = colors.light; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(x, y);
ctx.lineTo(cannonEndX, cannonEndY); ctx.stroke();

// Health bar ctx.fillStyle = '#1f2937';
ctx.fillRect(x - 16, y - 18, 32, 5);
ctx.strokeStyle = '#374151';
ctx.lineWidth = 1;
ctx.strokeRect(x - 16, y - 18, 32, 5);

ctx.fillStyle = player.planeHealth > 50 ? '#22c55e' : player.planeHealth > 25 ? '#eab308' : '#ef4444';
ctx.fillRect(x - 16, y - 18, (player.planeHealth / 100) * 32, 5);

ctx.restore();
}

function drawProjectile(ctx, proj) { ctx.save();

if (proj.type === 'plasma') {
const gradient = ctx.createRadialGradient(proj.x, proj.y, 0, proj.x, proj.y, 14);
 
gradient.addColorStop(0, '#e9d5ff'); gradient.addColorStop(0.5, '#d8b4fe'); gradient.addColorStop(1, '#a78bfa'); ctx.fillStyle = gradient; ctx.shadowColor = '#d8b4fe'; ctx.shadowBlur = 20;
ctx.beginPath();
ctx.arc(proj.x, proj.y, 14, 0, Math.PI * 2); ctx.fill();

ctx.strokeStyle = '#f3e8ff'; ctx.lineWidth = 2; ctx.beginPath();
ctx.arc(proj.x, proj.y, 14, 0, Math.PI * 2); ctx.stroke();
} else if (proj.type === 'atomic') { ctx.fillStyle = '#d4fc79'; ctx.shadowColor = '#d4fc79'; ctx.shadowBlur = 15; ctx.beginPath();
ctx.arc(proj.x, proj.y, 10, 0, Math.PI * 2); ctx.fill();
} else if (proj.type === 'emp') {
const gradient = ctx.createRadialGradient(proj.x, proj.y, 0, proj.x, proj.y, 10); gradient.addColorStop(0, '#e9d5ff');
gradient.addColorStop(0.6, '#d8b4fe'); gradient.addColorStop(1, '#b39ddb'); ctx.fillStyle = gradient; ctx.shadowColor = '#d8b4fe'; ctx.shadowBlur = 15;
ctx.beginPath();
ctx.arc(proj.x, proj.y, 10, 0, Math.PI * 2); ctx.fill();

ctx.strokeStyle = '#f3e8ff'; ctx.lineWidth = 2;
for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) { const x1 = proj.x + Math.cos(angle) * 10;
const y1 = proj.y + Math.sin(angle) * 10; const x2 = proj.x + Math.cos(angle) * 15; const y2 = proj.y + Math.sin(angle) * 15; ctx.beginPath();
ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
 
ctx.stroke();
}
} else if (proj.type === 'guided') { ctx.fillStyle = '#67e8f9'; ctx.shadowColor = '#67e8f9'; ctx.shadowBlur = 10; ctx.beginPath();
ctx.arc(proj.x, proj.y, 8, 0, Math.PI * 2); ctx.fill();
} else if (proj.type === 'sniper') { ctx.fillStyle = '#f0f9ff'; ctx.shadowColor = '#f0f9ff'; ctx.shadowBlur = 8; ctx.beginPath();
ctx.arc(proj.x, proj.y, 4, 0, Math.PI * 2); ctx.fill();
} else {
const size = proj.type === 'large' ? 8 : proj.type === 'medium' ? 6 : proj.type === 'cannonball' ? 7 : 5;
ctx.fillStyle = '#9ca3af'; ctx.shadowColor = '#6b7280'; ctx.shadowBlur = 4; ctx.beginPath();
ctx.arc(proj.x, proj.y, size, 0, Math.PI * 2); ctx.fill();

ctx.fillStyle = '#d1d5db'; ctx.beginPath();
ctx.arc(proj.x - 1.5, proj.y - 1.5, size * 0.4, 0, Math.PI * 2); ctx.fill();
}

ctx.restore();
}

function drawBeamLine(ctx, beam) { ctx.save();

if (beam.isFlame) {
// Flame beam
const beamWidth = 35;
const dx = beam.endX - beam.startX; const dy = beam.endY - beam.startY; const len = Math.hypot(dx, dy);
 
const nx = -dy / len * beamWidth / 2; const ny = dx / len * beamWidth / 2;

const gradient = ctx.createLinearGradient(beam.startX, beam.startY, beam.endX, beam.endY);
gradient.addColorStop(0, 'rgba(255, 200, 0, 0.8)');
gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.9)');
gradient.addColorStop(1, 'rgba(200, 50, 0, 0.5)');

ctx.fillStyle = gradient; ctx.beginPath();
ctx.moveTo(beam.startX + nx, beam.startY + ny); ctx.lineTo(beam.endX + nx, beam.endY + ny); ctx.lineTo(beam.endX - nx, beam.endY - ny); ctx.lineTo(beam.startX - nx, beam.startY - ny); ctx.closePath();
ctx.fill();

ctx.shadowColor = '#f97316'; ctx.shadowBlur = 20;

// Flame particles
for (let i = 0; i < 5; i++) { const t = Math.random();
const px = beam.startX + (beam.endX - beam.startX) * t; const py = beam.startY + (beam.endY - beam.startY) * t; ctx.fillStyle = `rgba(255, ${150 - i * 30}, 0, ${0.6 - i * 0.1})`; ctx.beginPath();
ctx.arc(px, py, 8 - i * 1.5, 0, Math.PI * 2); ctx.fill();
}
} else {
// Plasma beam ctx.strokeStyle = '#a855f7'; ctx.lineWidth = 4;
ctx.globalAlpha = 0.8; ctx.lineCap = 'round'; ctx.lineJoin = 'round';

ctx.beginPath(); ctx.moveTo(beam.startX, beam.startY); ctx.lineTo(beam.endX, beam.endY); ctx.stroke();
 
ctx.strokeStyle = '#c084fc'; ctx.lineWidth = 2;
ctx.globalAlpha = 0.6; ctx.beginPath();
ctx.moveTo(beam.startX, beam.startY); ctx.lineTo(beam.endX, beam.endY); ctx.stroke();

ctx.globalAlpha = 0.4; ctx.strokeStyle = '#e9d5ff'; ctx.lineWidth = 8; ctx.beginPath();
ctx.moveTo(beam.startX, beam.startY); ctx.lineTo(beam.endX, beam.endY); ctx.stroke();
}

ctx.restore();
}

function openLuckyBox(tier) {
    const player = gameState.players[gameState.currentPlayerIndex]; 
    const roll = Math.random() * 100;
    
    if (tier === 1) {
        if (roll < 20) { 
            player.weapons.push('medium');   // Always push, duplicates allowed
        } else if (roll < 40) { 
            player.weapons.push('cannonball');
        } else if (roll < 60) { 
            if (!player.isPlane && !player.empDisabled) {
                player.gas = Math.min(100, player.gas + 25);
            } 
        } else if (roll < 80) { 
            if (player.isPlane) {
                player.planeHealth = Math.min(100, player.planeHealth + 25);
            } else {
                player.health = Math.min(100, player.health + 25);
            }
        } else { 
            player.money += 100;
        }
        
    } else if (tier === 2) {
        if (roll < 17) { 
            player.weapons.push('large');
        } else if (roll < 34) { 
            player.weapons.push('sniper');
        } else if (roll < 51) { 
            player.weapons.push('guided');
        } else if (roll < 65) { 
            if (!player.isPlane && !player.empDisabled) {
                player.gas = Math.min(100, player.gas + 40);
            } else {
                player.money += 50;
            }
        } else if (roll < 79) { 
            if (player.isPlane) {
                player.planeHealth = Math.min(100, player.planeHealth + 40);
            } else {
                player.health = Math.min(100, player.health + 40);
            }
        } else { 
            player.money += 250;
        }
        
    } else if (tier === 3) {
        if (roll < 15) { 
            player.weapons.push('atomic');
        } else if (roll < 30) { 
            player.weapons.push('plasma');
        } else if (roll < 45) { 
            player.weapons.push('emp');
        } else if (roll < 60) { 
            player.weapons.push('airstrike');
        } else if (roll < 70) { 
            if (player.isPlane) {
                player.planeHealth = Math.min(100, player.planeHealth + 50);
            } else {
                player.health = Math.min(100, player.health + 50);
            }
        } else if (roll < 80) { 
            if (!player.isPlane && !player.empDisabled) {
                player.gas = Math.min(100, player.gas + 50);
            } else {
                player.money += 50;
            }
        } else { 
            player.money += 500;
        }
    }
    
    render();
}

function calculateLuckyBoxEV() {
    console.log("=== LUCKY BOX EXPECTED VALUE ANALYSIS ===");
    console.log("(Based on current probabilities)\n");
    
    // Calculate value per unit for shop items
    const gasValuePerUnit = 50 / 30; // $1.67 per unit of gas
    const healthValuePerUnit = 75 / 30; // $2.50 per unit of health
    
    // TIER 1 - $50 box
    // Probabilities from your code:
    // 0-20%: Medium (20%)
    // 20-40%: Cannonball (20%)
    // 40-60%: Gas (20%)
    // 60-80%: Health (20%)
    // 80-100%: Money (20%)
    let tier1EV = 0;
    
    tier1EV += 0.20 * 150; // Medium weapon
    tier1EV += 0.20 * 200; // Cannonball
    tier1EV += 0.20 * (25 * gasValuePerUnit); // Gas 25 units
    tier1EV += 0.20 * (25 * healthValuePerUnit); // Health 25 units
    tier1EV += 0.20 * 100; // Money
    
    console.log(`Tier 1 ($50 box) EV: $${tier1EV.toFixed(2)}`);
    console.log(`  Probabilities: 20% each category`);
    console.log(`  ‚Üí ${(tier1EV/50).toFixed(2)}x box price\n`);
    
    // TIER 2 - $125 box
    // Probabilities from your code:
    // 0-17%: Large (17%)
    // 17-34%: Sniper (17%)
    // 34-51%: Guided (17%)
    // 51-65%: Gas (14%)
    // 65-79%: Health (14%)
    // 79-100%: Money (21%)  ‚Üê You were right!
    let tier2EV = 0;
    
    tier2EV += 0.17 * 250; // Large
    tier2EV += 0.17 * 300; // Sniper
    tier2EV += 0.17 * 400; // Guided
    tier2EV += 0.14 * (40 * gasValuePerUnit); // Gas 40 units (14%)
    tier2EV += 0.14 * (40 * healthValuePerUnit); // Health 40 units (14%)
    tier2EV += 0.21 * 250; // Money (21%)
    
    console.log(`Tier 2 ($125 box) EV: $${tier2EV.toFixed(2)}`);
    console.log(`  Probabilities: Large(17%) Sniper(17%) Guided(17%) Gas(14%) Health(14%) Money(21%)`);
    console.log(`  ‚Üí ${(tier2EV/125).toFixed(2)}x box price\n`);
    
    // TIER 3 - $200 box
    // Probabilities from your code:
    // 0-15%: Atomic (15%)
    // 15-30%: Plasma (15%)
    // 30-45%: EMP (15%)
    // 45-60%: Airstrike (15%)
    // 60-70%: Health (10%)
    // 70-80%: Gas (10%)
    // 80-100%: Money (20%)
    let tier3EV = 0;
    
    tier3EV += 0.15 * 500; // Atomic
    tier3EV += 0.15 * 450; // Plasma
    tier3EV += 0.15 * 550; // EMP
    tier3EV += 0.15 * 600; // Airstrike
    tier3EV += 0.10 * (50 * healthValuePerUnit); // Health 50 units
    tier3EV += 0.10 * (50 * gasValuePerUnit); // Gas 50 units
    tier3EV += 0.20 * 500; // Money
    
    console.log(`Tier 3 ($200 box) EV: $${tier3EV.toFixed(2)}`);
    console.log(`  Probabilities: Atomic(15%) Plasma(15%) EMP(15%) Airstrike(15%) Health(10%) Gas(10%) Money(20%)`);
    console.log(`  ‚Üí ${(tier3EV/200).toFixed(2)}x box price`);
    
    return { tier1EV, tier2EV, tier3EV };
}

// Call it to see the results
calculateLuckyBoxEV();

// Keyboard controls
document.addEventListener('keydown', (e) => {
    if (gameState.phase !== 'playing') return;

    const currentPlayer = gameState.players[gameState.currentPlayerIndex];
    if (!currentPlayer || !currentPlayer.alive) return;

    switch (e.key.toLowerCase()) {
        case 'a':
            if (!currentPlayer.isPlane) window.tankWars.moveTank(-1); 
            break;
        case 'd':
            if (!currentPlayer.isPlane) window.tankWars.moveTank(1);
            break;
        case 'arrowup':
            e.preventDefault();
            window.tankWars.adjustPower(POWER_INCREMENT);
            break;
        case 'arrowdown':
            e.preventDefault();
            window.tankWars.adjustPower(-POWER_INCREMENT);
            break;
        case 'arrowleft':
            e.preventDefault();
            window.tankWars.adjustAngle(ANGLE_INCREMENT);
            break;
        case 'arrowright':
            e.preventDefault();
            window.tankWars.adjustAngle(-ANGLE_INCREMENT);
            break;
        case ' ':
        case 'enter':
            e.preventDefault();
            window.tankWars.fire();
            break;
    }
});

render();
</script>